# PlAsm
PlAsm is an assembly-like format created for the virtual machine's bytecode. Its structure is designed to be simple to use.

## Syntax
The syntax of the language consists of instructions, parameters, and labels. An example program uses all of these:
```
start:
  push 10

loop:
  push 1
  sub
  brneq 0 :loop
  halt
```

The language is not indentation-sensitive, however newlines are treated as a separator character. If writing code on one line, you may use semicolons as an alternative separator. Be sure to leave a space between
each instruction and its parameters:
```
start:;push 10;loop:;push 1;sub;brneq 0,:loop;halt;
```

## Instructions
Instructions are the base of the language. Every bytecode in the virtual machine corresponds to one alphanumeric instruction. For example, **No-op** is represented by `noop` in the language.

Instructions may take a number of arguments. In this case, each argument is to be supplied as an integer, `0x`-prefixed hexadecimal number, or a `:label` label reference. For example, the `push` - **Push** instruction takes 1 4-byte argument, which is pushed to the stack.
In this case, we would write it like:
```
push 50
```
or, using hexadecimal:
```
push 0x32
```

For instructions that require an address to jump to, it is recommended you use labels:
```
jmp :label
```
The assembler will automatically replace label references with the addresses of the label definitions at compile time.


Some instructions may take multiple arguments. In this case, separate all the arguments using spaces or commas:
```
breq 0 :start
breq 0, :start

```

### Data types
The language does not have any notion of data types; Integer literals, hexadecimal literals and labels may all be used interchangeably. However, the language does enforce data sizes. For example, the `brrand` - **Branch Random** instruction
expects a single byte as its first argument. Attempting to supply a number like 260, 0xFFFF, or a label will fail. 

Attempting to supply a smaller-sized number where a larger one is expected will not fail, however. For example, `push 2` is a valid instruction. The 2 will simply be widened in the byte code.

Hexadecimal numbers must be provided in big endian 2-character pairs. `0xFFF`, `0xFFFFF`, etc. will not be considered valid hexadecimal numbers.

## Labels
Labels are declared with the syntax `name:`. They are purely for working with addresses and jumps and do not affect the produced bytecode in any way. They are always size 4.

The one exception is the label `start:`. The `start:` label marks the intended entry point of a program. If one is included, then a JMP instruction is automatically inserted at the start of the code.

## Constants
Constants are aliases to constant values. They can be declared using `.const`.

Constants are declared using the `.const` keyword. It expects 2 - 3 parameters:
  - name: an available symbol
  - value: the value of the constant.
  - width (optional): the width (in bytes) of the constant. If this is not provided, it will occupy the smallest number of bytes it can.

For example,
```
  .const valA 0x0002
  .const valB 0x02 4
```
valA will occupy 2 bytes, and valB will occupy 4 since an explicit width has been provided. If it were not provided, valB would only occupy 1 byte.

The declared constant can then be referenced in code:
```
  push .valA
  push .valB
```
Both instructions are valid even though push accepts a 4 byte value. Constants will still be widened as necessary.

## Data
Data is a series of bytes that are inserted into the generated bytecode. Data is created using the `.data` keyword, and accepts 1 parameter:
  - data: A value or list of values. Lists must be denoted by parenthesis

For example,
```
data:
  .data 0x00000000
  .data 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF
  .data .valA, .valB
```

Data is processed after constants are and as a result are able to reference other constants. It may also reference labels, as labels are fixed-size.

Data will be inserted in-place into the program. For this reason, it is recommended you declare data at the start of your program and add a `start:` label. Otherwise,
you risk the data being executed as code.

To get the address of the data, you may use a label as normal.